"use strict";(self.webpackChunkreact_native_testing_library_website=self.webpackChunkreact_native_testing_library_website||[]).push([[690],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return g}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,g=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?r.createElement(g,o(o({ref:t},p),{},{components:n})):r.createElement(g,o({ref:t},p))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7454:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return g},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return u}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={id:"migration-v9",title:"Migration to 9.0"},l=void 0,c={unversionedId:"migration-v9",id:"migration-v9",title:"Migration to 9.0",description:"Version 7.0 brought React Native Testing Library into the @testing-library family. Since it has been implemented independently from its web counterpart \u2013 the React Testing Library \u2013 there are some differences in the API and behavior. Version 9.0 solves several of these problems.",source:"@site/docs/MigrationV9.md",sourceDirName:".",slug:"/migration-v9",permalink:"/react-native-testing-library/docs/migration-v9",draft:!1,editUrl:"https://github.com/callstack/react-native-testing-library/blob/main/docs/MigrationV9.md",tags:[],version:"current",frontMatter:{id:"migration-v9",title:"Migration to 9.0"},sidebar:"docs",previous:{title:"Migration to 11.0",permalink:"/react-native-testing-library/docs/migration-v11"},next:{title:"Migration to 7.0",permalink:"/react-native-testing-library/docs/migration-v7"}},p={},u=[{value:"Support for text match options a.k.a string precision API",id:"support-for-text-match-options-aka-string-precision-api",level:2},{value:"Reverted matching text across several nodes",id:"reverted-matching-text-across-several-nodes",level:2},{value:"Future plans",id:"future-plans",level:2}],d={toc:u},m="wrapper";function g(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)(m,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Version 7.0 brought React Native Testing Library into the ",(0,i.kt)("inlineCode",{parentName:"p"},"@testing-library")," family. Since it has been implemented independently from its web counterpart \u2013 the React Testing Library \u2013 there are some differences in the API and behavior. Version 9.0 solves several of these problems."),(0,i.kt)("h2",{id:"support-for-text-match-options-aka-string-precision-api"},"Support for text match options a.k.a string precision API"),(0,i.kt)("p",null,"This is a backward compatible change."),(0,i.kt)("p",null,"When querying text, it is now possible to pass a ",(0,i.kt)("a",{parentName:"p",href:"https://callstack.github.io/react-native-testing-library/docs/api-queries/#textmatch"},(0,i.kt)("inlineCode",{parentName:"a"},"TextMatch"))," to most text based queries, which lets you configure how ",(0,i.kt)("inlineCode",{parentName:"p"},"@testing-library/react-native")," should match your text. For instance, passing ",(0,i.kt)("inlineCode",{parentName:"p"},"exact: false")," will allow matching substrings and will ignore case:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const { getByText } = render(<Text>Hello World</Text>);\n\ngetByText('Hello World'); // Matches\ngetByText('Hello'); // Doesn't match\ngetByText('hello', { exact: false }); // ignore case-sensitivity and does partial matching\n")),(0,i.kt)("p",null,"Please note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"findBy*")," queries used to take a ",(0,i.kt)("inlineCode",{parentName:"p"},"waitForOptions")," parameter as a second argument, which has now been moved to the third argument:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"-findByText('Hello world', { timeout: 3000 }); // old findBy* API\n+findByText('Hello world', {}, { timeout: 3000 }); // new findBy* API\n")),(0,i.kt)("p",null,"For backward compatibility RNTL v9 can still read ",(0,i.kt)("inlineCode",{parentName:"p"},"waitForOptions")," from the second argument but will print a deprecation warning."),(0,i.kt)("h2",{id:"reverted-matching-text-across-several-nodes"},"Reverted matching text across several nodes"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"This is a breaking change.")),(0,i.kt)("p",null,"In v1.14 we've introduced a feature allowing to match text when it's spread across several nodes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const { getByText } = render(\n  <Text>\n    Hello <Text>world</Text>\n  </Text>\n);\ngetByText('Hello world'); // matches\n")),(0,i.kt)("p",null,"However this behavior was different than the web one, and wouldn't always be straightforward to reason about. For instance it could match text nodes far from each other on the screen. It also prevented us from implementing the string precision API. From v9, this type of match will not work."),(0,i.kt)("p",null,"A work around is to use ",(0,i.kt)("inlineCode",{parentName:"p"},"within"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import {Text} from 'react-native'\nimport {render, within} from '@testing-library/react-native'\n\nconst {getByText} = render(<Text>Hello <Text>world</Text</Text>)\n\nwithin(getByText('Hello', {exact: false})).getByText('world')\n")),(0,i.kt)("h2",{id:"future-plans"},"Future plans"),(0,i.kt)("p",null,"This release changes a lot of internal logic in the library, paving the way for more improvements to bring us closer to our web counterpart, with a possibly better story for accessibility queries."),(0,i.kt)("p",null,"We're also ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/callstack/react-native-testing-library/issues/877"},"migrating the codebase to TypeScript"),". Please let us know if you're interested in helping us with this effort."),(0,i.kt)("p",null,"Stay safe!"))}g.isMDXComponent=!0}}]);