"use strict";(self.webpackChunkreact_native_testing_library_website=self.webpackChunkreact_native_testing_library_website||[]).push([[381],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return k}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),c=i,k=m["".concat(o,".").concat(c)]||m[c]||d[c]||r;return n?a.createElement(k,l(l({ref:t},u),{},{components:n})):a.createElement(k,l({ref:t},u))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[m]="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4880:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return o},default:function(){return k},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return m}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],s={id:"user-event",title:"User Event"},o=void 0,p={unversionedId:"user-event",id:"user-event",title:"User Event",description:"Table of contents",source:"@site/docs/UserEvent.md",sourceDirName:".",slug:"/user-event",permalink:"/react-native-testing-library/docs/user-event",draft:!1,editUrl:"https://github.com/callstack/react-native-testing-library/blob/main/website/docs/UserEvent.md",tags:[],version:"current",frontMatter:{id:"user-event",title:"User Event"},sidebar:"docs",previous:{title:"Queries",permalink:"/react-native-testing-library/docs/api-queries"},next:{title:"Troubleshooting",permalink:"/react-native-testing-library/docs/troubleshooting"}},u={},m=[{value:"Table of contents",id:"table-of-contents",level:3},{value:"Comparison with Fire Event API",id:"comparison-with-fire-event-api",level:2},{value:"<code>setup()</code>",id:"setup",level:2},{value:"Options",id:"options",level:3},{value:"<code>press()</code>",id:"press",level:2},{value:"<code>longPress()</code>",id:"longpress",level:2},{value:"Options",id:"options-1",level:3},{value:"<code>type()</code>",id:"type",level:2},{value:"Options",id:"options-2",level:3},{value:"Sequence of events",id:"sequence-of-events",level:3},{value:"<code>clear()</code>",id:"clear",level:2},{value:"Sequence of events",id:"sequence-of-events-1",level:3}],d={toc:m},c="wrapper";function k(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"table-of-contents"},"Table of contents"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#comparison-with-fire-event-api"},"Comparison with Fire Event API")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#setup"},(0,r.kt)("inlineCode",{parentName:"a"},"setup()")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#options"},"Options")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#press"},(0,r.kt)("inlineCode",{parentName:"a"},"press()"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#longpress"},(0,r.kt)("inlineCode",{parentName:"a"},"longPress()")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#options-1"},"Options")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#type"},(0,r.kt)("inlineCode",{parentName:"a"},"type()")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#options-2"},"Options")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#sequence-of-events"},"Sequence of events")))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#clear"},(0,r.kt)("inlineCode",{parentName:"a"},"clear()")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#sequence-of-events-1"},"Sequence of events"))))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"User Event API is in beta stage."),(0,r.kt)("p",{parentName:"admonition"},"This means that we plan to keep the public API signatures to remain stable, but we might introduce breaking behavioural changes, e.g. changing the ordering or timing of emitted events, without a major version update. Hopefully, well written code should not rely on such specific details.")),(0,r.kt)("h2",{id:"comparison-with-fire-event-api"},"Comparison with Fire Event API"),(0,r.kt)("p",null,"Fire Event is our original event simulation API. It offers ability to invoke ",(0,r.kt)("strong",{parentName:"p"},"any event handler")," declared on ",(0,r.kt)("strong",{parentName:"p"},"either host or composite elements"),". If the element does not have ",(0,r.kt)("inlineCode",{parentName:"p"},"onEventName")," event handler for passed ",(0,r.kt)("inlineCode",{parentName:"p"},"eventName")," event, or the element is disabled, Fire Event will traverse up the component tree, looking for event handler on both host and composite elements along the way. By default it will ",(0,r.kt)("strong",{parentName:"p"},"not pass any event data"),", but the user might provide it in the last argument."),(0,r.kt)("p",null,"In contrast, User Event provides realistic event simulation for main user interactions like ",(0,r.kt)("inlineCode",{parentName:"p"},"press")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),". Each of the interactions will trigger a ",(0,r.kt)("strong",{parentName:"p"},"sequence of events")," corresponding to React Native runtime behavior. These events will be invoked ",(0,r.kt)("strong",{parentName:"p"},"only on host elements"),", and ",(0,r.kt)("strong",{parentName:"p"},"will automatically receive event data")," corresponding to each event."),(0,r.kt)("p",null,"If User Event supports given interaction you should always prefer it over Fire Event counterpart, as it will make your tests much more realistic and hence reliable. In other cases, e.g. when event is not supported by User Event, or when invoking event handlers on composite elements, you have to use Fire Event as the only available option."),(0,r.kt)("h2",{id:"setup"},(0,r.kt)("inlineCode",{parentName:"h2"},"setup()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"userEvent.setup(options?: {\n  delay: number;\n  advanceTimers: (delay: number) => Promise<void> | void;\n})\n")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const user = userEvent.setup();\n")),(0,r.kt)("p",null,"Creates an User Event object instance which can be used to trigger events."),(0,r.kt)("h3",{id:"options"},"Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"delay")," - controls the default delay between subsequent events, e.g. keystrokes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"advanceTimers")," - time advancement utility function that should be used for fake timers. The default setup handles both real timers and Jest fake timers.")),(0,r.kt)("h2",{id:"press"},(0,r.kt)("inlineCode",{parentName:"h2"},"press()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"press(\n  element: ReactTestInstance,\n): Promise<void>\n")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const user = userEvent.setup();\nawait user.press(element);\n")),(0,r.kt)("p",null,"This helper simulates a press on any pressable element, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"Pressable"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TouchableOpacity"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Text"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"TextInput"),", etc. Unlike ",(0,r.kt)("inlineCode",{parentName:"p"},"fireEvent.press()")," which is a simpler API that will only call the ",(0,r.kt)("inlineCode",{parentName:"p"},"onPress")," prop, this function simulates the entire press interaction in a more realistic way by reproducing event sequence emitted by React Native runtime. This helper will trigger additional events like ",(0,r.kt)("inlineCode",{parentName:"p"},"pressIn")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"pressOut"),". "),(0,r.kt)("h2",{id:"longpress"},(0,r.kt)("inlineCode",{parentName:"h2"},"longPress()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"longPress(\n  element: ReactTestInstance,\n  options: { duration: number } = { duration: 500 }\n): Promise<void>\n")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const user = userEvent.setup();\nawait user.longPress(element);\n")),(0,r.kt)("p",null,"Simulates a long press user interaction. In React Native the ",(0,r.kt)("inlineCode",{parentName:"p"},"longPress")," event is emitted when the press duration exceeds long press threshold (by default 500 ms). In other aspects this actions behaves similar to regular ",(0,r.kt)("inlineCode",{parentName:"p"},"press")," action, e.g. by emitting ",(0,r.kt)("inlineCode",{parentName:"p"},"pressIn")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"pressOut")," events. The press duration is customisable through the options. This should be useful if you use the ",(0,r.kt)("inlineCode",{parentName:"p"},"delayLongPress")," prop. When using real timers this will take 500 ms so it is highly recommended to use that API with fake timers to prevent test taking a long time to run. "),(0,r.kt)("h3",{id:"options-1"},"Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"duration")," - duration of the press in miliseconds. Default value is 500 ms.")),(0,r.kt)("h2",{id:"type"},(0,r.kt)("inlineCode",{parentName:"h2"},"type()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type(\n  element: ReactTestInstance,\n  text: string,\n  options?: {\n    skipPress?: boolean\n    submitEditing?: boolean\n  }\n")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const user = userEvent.setup();\nawait user.type(textInput, "Hello world!");\n')),(0,r.kt)("p",null,"This helper simulates user focusing on ",(0,r.kt)("inlineCode",{parentName:"p"},"TextInput")," element, typing ",(0,r.kt)("inlineCode",{parentName:"p"},"text")," one character at a time, and leaving the element."),(0,r.kt)("p",null,"This function supports only host ",(0,r.kt)("inlineCode",{parentName:"p"},"TextInput")," elements. Passing other element type will result in throwing error."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This function will add text to the text already present in the text input (as specified by ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"defaultValue")," props). In order to replace existing text, use ",(0,r.kt)("a",{parentName:"p",href:"#clear"},(0,r.kt)("inlineCode",{parentName:"a"},"clear()"))," helper first.")),(0,r.kt)("h3",{id:"options-2"},"Options"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"skipPress")," - if true, ",(0,r.kt)("inlineCode",{parentName:"li"},"pressIn")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"pressOut")," events will not be triggered."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"submitEditing")," - if true, ",(0,r.kt)("inlineCode",{parentName:"li"},"submitEditing")," event will be triggered after typing the text.")),(0,r.kt)("h3",{id:"sequence-of-events"},"Sequence of events"),(0,r.kt)("p",null,"The sequence of events depends on ",(0,r.kt)("inlineCode",{parentName:"p"},"multiline")," prop, as well as passed options."),(0,r.kt)("p",null,"Events will not be emitted if ",(0,r.kt)("inlineCode",{parentName:"p"},"editable")," prop is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Entering the element"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pressIn")," (optional)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"focus")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pressOut")," (optional)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"pressIn")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"pressOut")," events are sent by default, but can be skipped by passing ",(0,r.kt)("inlineCode",{parentName:"p"},"skipPress: true")," option."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Typing (for each character)"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"keyPress")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"textInput")," (optional)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"change")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"changeText")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"selectionChange"))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"textInput")," event is sent only for mutliline text inputs."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Leaving the element"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"submitEditing")," (optional)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endEditing")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blur"))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"submitEditing")," event is skipped by default. It can sent by setting ",(0,r.kt)("inlineCode",{parentName:"p"},"submitEditing: true")," option."),(0,r.kt)("h2",{id:"clear"},(0,r.kt)("inlineCode",{parentName:"h2"},"clear()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"clear(\n  element: ReactTestInstance,\n}\n")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const user = userEvent.setup();\nawait user.clear(textInput);\n")),(0,r.kt)("p",null,"This helper simulates user clearing content of ",(0,r.kt)("inlineCode",{parentName:"p"},"TextInput")," element."),(0,r.kt)("p",null,"This function supports only host ",(0,r.kt)("inlineCode",{parentName:"p"},"TextInput")," elements. Passing other element type will result in throwing error."),(0,r.kt)("h3",{id:"sequence-of-events-1"},"Sequence of events"),(0,r.kt)("p",null,"The sequence of events depends on ",(0,r.kt)("inlineCode",{parentName:"p"},"multiline")," prop, as well as passed options."),(0,r.kt)("p",null,"Events will not be emitted if ",(0,r.kt)("inlineCode",{parentName:"p"},"editable")," prop is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Entering the element"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"focus"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Selecting all content"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"selectionChange"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Pressing backspace"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"keyPress")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"textInput")," (optional)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"change")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"changeText")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"selectionChange"))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"textInput")," event is sent only for mutliline text inputs."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Leaving the element"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"endEditing")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"blur"))))}k.isMDXComponent=!0}}]);